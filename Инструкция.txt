Всем привет!
Для пользованья этим движком, вам нужна Visual Studio, небольшие знания C# и он сам. Если у Вас чего то из этого нету, либо установите, либо можете удалять эту программу.

Краткая История.
Название моего движка переводится как "Анти Единство". Это не потому, что он плохой. Просто, я его создал, чтобы не пользоваться Unity и увести всех его пользователей к себе. А ещё у меня Unity не особо тянет но про это какнибудь потом...

Основы.
Мой движок работает на сценах, как и Unity. Также оба движка должны иметь входную сцену. В противном случае, AntiUnity закроется, не показав даже заставки.
Начнём.
...
Ищем файл класса "Programm.cs" и открываем его. Далее смотрим на класс "Game", а в нём - на функцию "Setup".
Она и является входной функцией для моего движка.

Оформление окна.
Чтобы настроить статичное окно движка, пропишите такую строчку:
Engine.SetupWindow(800,500);
Первый аргумент - ширина, второй - высота. Думаю, тут всё понятно.
Чтобы присвоить вашему окну имя, пропишите это:
Engine.SetTitle("Some Title");
Первый аргумент - тайтл вашего приложения.
Присвоение иконки:
Engine.SetIcon("path_to_icon.png", 32);
Первый аргумент - путь, второй - разрешение.
Чтобы сменить иконку самого приложения, вам нужно зайти в настройки проекта и поменять её.
Чтобы запустить движок(Обязательная функция), нужно написать:
Engine.Start();
После этого вам не будет доступны функции выше.

Графика.
Мой движок создан на библеотеках SFML. Он поддерживает только 2D, но благодаря моему движку вы сможете моделировать разные объекты и т.п. Об этом ниже.

Моделирование:
Мой движок поддерживает моделирование и даже имеет программу для этого. Чтобы её вызвать, нужно прописать:
Engine.ModelEditorOpen();
О том, как ей пользоваться, читайте в файле "Инструкция для ModelMaker.txt".

Как создать сцену?
Чтож, настало время создать сцену. Вы должны объявить две функции, одна из которых - входная, другая - обновляемая.
(Start,Update в Unity). Далее вы пишите такую строчку:
Engine.AddScene(Start,Update,"Scene");
Третий аргумент - уникальное название вашей сцены, при его повторении движок выдаст ошибку.
Вместо первого или второго аргумента можно прописать "null", если вы, например, не хотите, чтобы в этой сцене была начальная или обновляемая функция. Но если в обоих аргументах прописать "null", то движок выдаст ошибку, так как вы попытались создать пустую сцену.
Чтобы запустить сцену, можете написать так:
Engine.LoadScene("Scene name");
Первый аргумент - имя сцены.
Чтобы поставить первую сцену:
Engine.SetFirstScene("Scene name");

Вывод модели и не только.
Для начала, Вам нужно создать модель. Вы, конечно, можете создать её вручную, но я даже этот вариант рассматривать не буду. В редакторе моделей вы создали и сохранили её.
Чтобы восстановить её в коде, вот что нужно сделать:
Model mdl = Saver.OpenModel("path");
Первый аргумент - путь к модели.
Также есть ещё один тип объектов - ModelObject.
Он служит для создания моделей, и его НЕЛЬЗЯ моделировать, а также у него не может быть коллайдера,
создать его можно только вручную.
Чтобы вывести полученную вами модель, пропишите:
Engine.AddModelToRender(mdl);
Где mdl - ваша модель.
Можно также это сделать это с объектами:
Engine.AddObjectToRender(obj);
Где obj - ваш ModelObject.
Все эти функции возвращают id этих объектов, которые потом вам пригодятся.
Чтобы дать приоритет какому либо объекту, пропишите:
Engine.Prioritete(5,"model");
Первый аргумент - айди, который вы получали выше, второй - тип приоритета(либо "model", либо "object"). Эта функция возвращает true или false, в зависимости от того, успешно ли прошла операция.
Чтобы удалить модель:
Engine.Model_RemoveFromRender(mdl);
В списке моделей для рендера будет искаться модель с такими же свойствами и удалится.
Для объектов:
Engine.Object_RemoveFromRender(obj);
Чтобы удалить объект рендера по айди, пропишите:
Engine.RemoveFromRender(5,"object");
Первый аргумент - айди, второй - тип выполнения задачи(или "model" или "object"). При неудаче выполнения эта функция ничего не сделает.
Создать текст тоже не очень сложно.
Пропишите:
Engine.RenderText("Hellow", Color.Black, 1.5f, 54, 34, "not-ui");
Эта функция создаёт текст для рендера и возвращает его Id.
Первый аргумент - текст.
Второй - цвет.
Третий - размер.
Четвёртый и пятый - float x,y.
Шестой - тип ("ui","not-ui")
Чтобы убрать текст, пропишите:
Engine.DisableText(5);
Аргумент - Id текста.
Чтобы его обновить, пропишите:
Engine.UpdateText(3, "new text");
Первый аргумент - Id текста,
Второй - новый текст.

Сохранение.
Для некоторых игр нужно сохранение. Чтобы сохранить текст в файл, введите:
Saver.DumpText("path", "hello");
Первый аргумент - путь,
Второй - текст.
Чтобы его получить из файла, пишите:
Saver.GetText("path");
Аргумент - путь.
Также есть функции:
Saver.GetLines("path");
Saver.DumpLines("path", string[] lines);
Второй аргумент - массив строк, которые вы хотите записать в файл.
Также, можно сохранять, открывать объекты и модели. Думаю, комментарии здесь излишни.
Saver.DumpModel(Model mdl,"path");
Saver.DumpObject(ModelObject obj,"path");
Model m = Saver.OpenModel("path");
ModelObject o = Saver.OpenObject("path");

Звуки и музыка.
К сожалению, sfml требует времени для загрузки звуков и музыки. Лучше сделать это вначале при загрузке игры.
Давайте сначала изучим структуру создания звуков в игре, а потом создадим сцену загрузки звуков.
Чтобы добавить звук, пропишите:
SoundManager.AddSound("path_to_sound.wav", "Name of sound", false);
Первый аргумент - путь к звуку,
Второй - имя звука,
Третий - будет ли звук повторяться(В моём случае нет)
Чтобы загрузить все звуки:
SoundManager.Load();
Это займёт некоторое время.
Вам нужно проиграть какой либо звук. Пишите:
SoundManager.Play("name of sound");
Чтобы его остановить, напишите:
SoundManager.StopSound("name of sound");
Примечание:
Мой движок не поддерживает некоторые форматы звуков, я понимаю, что это неудобно. Советую wav или ogg.

Клавиши и мышь.
Для начала, узнаем, как обозначаются клавиши в моём движке.
Сначала вы пишите:
Keyboard.Key
А затем клавишу. Например:
Keyboard.Key.A;
Keyboard.Key.LShift;
И так далее.
Чтобы проверить, нажата ли клавиша, нужно прописать:
Engine.IsKeyPressed(Keyboard.Key.A);
Аргумент - клавиша.
Чтобы узнать, нажата ли клавиша в данный момент, пропишите:
Engine.IsLeftButtonClicked(); //левая
Engine.IsRightButtonClicked(); //правая
Чтобы узнать её позицию относительно окна, нужно писать следующее:
point p = Engine.GetMousePosition();
p.x //X мыши
p.y //Y мыши
Чтобы получить коллайдер мыши, который пригодится, например, при создании кнопок:
Collider c = Engine.GetMouseCollider();
Как ими пользоваться вы узнаете далее.

Как выйти из игры?
Вам надоела игра? Вы подавлены? Вас нагрузило информацией? Вас зовут КУШАТЬ???
Неважно, пропишите:
Enigne.Quit();
Всё.

Все прекрасы моделей.
*В качестве нашей модели возьмём Model mdl = new Model();
Управлять моделями - цель движка. Начнём с её движения.
mdl.Move(15f,"left"); // 15 налево
mdl.Move(60f, "right"); // 60 направо
mdl.Move(30f, "up"); //30 наверх
mdl.Move(10f, "down"); //10 вниз
Если вы знаете такую функцию в Unity "MoveTowards", вы молодцы. У меня тоже тако есть.
point p = new point(); //создаём точку
p.x = 16; // Даём значения
p.y = 16;
mdl.MoveTowards(p,4); //двигаемся к точке p со временем 4.
mdl.MoveTowardsGentle(p, 6); //Плавно двигаемся к точке p со временем 6.
Спешу заметить, время в данной функции - не секунды. Это что-то на подобии шагов.
Вы можете увеличивать или уменьшать вашу модель:
mdl.Scale(4f);
Аргумент - во сколько раз увеличить\уменьшить модель.
Чтобы вернуть её в начальный размер, пропишите вместо первого аргумента "1f".
Также у моделей есть физика. Но она пока не очень проработана, могут быть баги.
Для начала работы с ней вам нужно прописать:
mdl.GivePhysics(5f); //даём модели вес 5.
Без этой функции обновление гравитации невозможно.
Чтобы сделать обновлении гравитации, пропишите:
mdl.Gravity(false);
Аргумент - это значение, будет ли действие гравитации противоположным.
Чтобы остановить гравитацию у модели, напишите:
mdl.StopGravity();

Коллизия.
Коллизия нужна везде.
Пожалуй, буду объяснять функции комментариями в коде.
bool i = Collision.Collide(mdl,new Model()); // прикосновение одной модели к другой
bool i = Collision.CollidePart(mdl,new Model(),0); //прокосновение одного коллайдера модели к другой
bool i = Collision.CollidePartTo(mdl, new Collider(),0); // прикосновение одного коллайдера к назначенному
bool i = Collision.CollidePartToTag(mdl,new Model(),"tag",0); //прикосновение одного коллайдера модели к коллайдерам другой модели, у которых есть указанный тэг
bool i = Collision.CollideTo(mdl,new Collider()); // прикосновение модели к указанному коллайдеру
bool i = Collision.CollideToTag(mdl,new Model(), "tag"); // прикосновение модели к коллайдерам другой, у которых есть указанный тэг.
Фух, очень сложно объяснить все смыслы этих функций :D








 



